import Image from 'next/image'
import { ResultsTable } from '@/components/results-table'
import { FlowDiagram } from '@/components/flow-diagram'
import { ZoomableImage } from '@/components/ui/zoomable-image'

export const metadata = {
  title: 'Automating the Studio Coordinator',
  description: 'A technical case study on replacing a manual 10-hour/week workflow with a Serverless TypeScript architecture.',
}

<div className="not-prose mb-8 overflow-hidden rounded-2xl bg-zinc-50/40 p-1 ring-1 ring-zinc-200/50 ring-inset dark:bg-zinc-950/40 dark:ring-zinc-800/50">
  <ZoomableImage
    src="/automating email.png"
    alt="Automating the Studio Coordinator"
    width={1200}
    height={675}
    className="w-full rounded-xl object-cover"
    priority
  />
</div>

# Case Study: Automating the Studio Coordinator

**Role:** Technical Product Manager & Developer  
**Timeline:** 2 Weeks (Prototype to Production)  
**Tech Stack:** TypeScript, Vercel (Serverless), Google Gemini (AI), Google Pub/Sub

## 1. The Problem: The "Admin Bottleneck"

As TRISP Studio grew, I faced a scaling problem. Responding to inquiries was costing me valuable time that should have been spent shooting or editing.

*   **User Pain Point:** Clients sent vague, free-form emails ("Are you free Nov 24?") and expected instant replies.
*   **Operational Pain Point:** Responding required context-switching between 4 tabs: Gmail, Calendar, Pricing Sheets, and Policy Docs.
*   **The Metric:** Average response time was ~4 hours. Customer acquisition cost (in time) was unsustainable.

## 2. The Prototype (And Why I Killed It)

I initially built a no-code MVP using n8n. It validated the value proposition but failed as a production product.

*   **Latency (Execution Overhead):** The workflow was "heavy." For every single inquiry, it had to connect to Google Drive, download my policy PDFs, and extract the text before it could even start thinking. This added significant friction and failure points.
*   **Fragility:** Business logic was hidden inside the proprietary JSON configurations of visual nodes. Versioning meant duplicating the entire workflow file.
*   **Cost:** Running these heavy file-processing workflows at scale would cost ~$50-70/month.

**The Pivot:** I decided to re-platform to a **Serverless TypeScript Architecture**. By hardcoding the policies into lightweight TypeScript files, I eliminated the need for file downloads, reducing execution time from minutes to milliseconds.

> [!NOTE]
> *[Place N8N Screenshot here] vs [Place VS Code Screenshot here]*

## 3. The Solution: Engineering Trade-offs

This section highlights the specific technical challenges I solved during the build.

### The Flow: Event-Driven Automation

<div className="not-prose my-12 -mx-6 md:mx-0 overflow-x-auto">
    <FlowDiagram />
</div>


#### 1. Trigger: Pub/Sub Webhook
Gmail receives the email (`Photography Inquiry`). Google Pub/Sub detects the change instantly and fires a webhook to Vercel.

#### 2. Check State: Gmail API (Read)
Immediately locks the thread by labeling it `processed by TRISP AI` to prevent race conditions (Optimistic Locking).

#### 3. Extract: Gemini AI (JSON)
Sends the raw email text to Gemini AI to get clean JSON: `{ name, date, session_type }`.

#### 4. Availability: Google Calendar API
Checks Google Calendar for availability (calculating "Day Before/After" alternatives if busy).

#### 5. Draft: Gemini AI + Config Files
Drafts the response using the full configuration suite: Filtered Pricing, Policies (Deposits/Late Fees), FAQs, Brand Voice, and Sample Emails.

#### 6. Save: Gmail API (Write)
Inserts the generated text as a Draft in the original thread.

### Challenge A: The "No-Database" Architecture

*   **The Constraint:** I wanted a "stateless" architecture to avoid managing (and paying for) a PostgreSQL database just to track email status.
*   **The Solution:** I utilized **Gmail API Labels** as my state machine. The system applies a `Processed by TRISP AI` label the moment ingestion begins, flagging the thread as 'in-progress' to prevent other processes from touching it.
*   **Result:** Zero infrastructure cost for state management.

### Challenge B: Handling Race Conditions

*   **The Bug:** Pub/Sub webhooks occasionally fire twice (at-least-once delivery). During testing, this caused the AI to draft two identical replies to the same client.
*   **The Fix:** I implemented a multi-layered **Idempotency Strategy**. First, the system checks if a draft already exists. Second, it immediately "locks" the thread by applying the processed label before initiating the slow AI operations.
*   **Code Concept:** `await markEmailProcessed(msg.threadId); // Lock before AI work`

### Challenge C: Preventing AI "Hallucinations"

*   **The Risk:** Generative AI can be overly optimistic, promising dates or prices that don't exist.
*   **The Guardrails (Separation of Concerns):**
    1.  **Deterministic Logic:** I hardcoded the "Truth" (pricing, policies) into version-controlled TypeScript files. The AI cannot guess prices; it must read from the config.
    2.  **Defensive Prompting:** I engineered a system prompt with negative constraints: *"MISTAKES TO AVOID: ‚ùå Saying 'your vision sounds amazing' when no vision was described."*
    3.  **Fallback Math:** Instead of asking AI if I'm free, the code queries the Google Calendar API. If a slot is taken, the algorithm calculates 3 alternative slots based on availability logic.

## 4. The Result: Impact by the Numbers

<div className="not-prose my-8">
  <ResultsTable />
</div>

> [!NOTE]
> *[Place Final Email Screenshot here]*

## 5. Retrospective

If I were to rebuild this, I would implement **RAG (Retrieval-Augmented Generation)** for the FAQ section. Currently, FAQs are a static array in the code. As the business grows, indexing past email threads to answer complex context-dependent questions (e.g., "Can I bring my dog to the studio vs. the park?") would further improve draft quality.
