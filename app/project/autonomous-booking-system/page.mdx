
import Image from 'next/image'
import { ResultsTable } from '@/components/results-table'
import { FlowDiagram } from '@/components/flow-diagram'
import { ZoomableImage } from '@/components/ui/zoomable-image'
import { BookingAgentDemo } from '@/components/booking-agent-demo'
import { WorkflowComparisonTable } from '@/components/workflow-comparison-table'

export const metadata = {
  title: 'Autonomous Booking System',
  description: 'Re-architecting a manual triage workflow into a fully automated serverless system, eliminating operational bottlenecks and enabling 24/7 inquiry handling.',
}

<div className="not-prose mb-8 overflow-hidden rounded-2xl bg-zinc-50/40 p-1 ring-1 ring-zinc-200/50 ring-inset dark:bg-zinc-950/40 dark:ring-zinc-800/50">
  <ZoomableImage
    src="/automating email.png"
    alt="Autonomous Booking System: Hours to Seconds"
    width={1200}
    height={675}
    className="w-full rounded-xl object-cover"
    priority
  />
</div>

# Autonomous Booking System

**Role:** Technical Product Manager & Developer | **Timeline:** Oct 2025 - Present  
**Tech Stack:** TypeScript, Vercel Serverless Functions, Google Gemini AI, Google Pub/Sub, Gmail API

---

## Overview

A fully automated, event-driven system that handles photography inquiries instantly. By replacing a manual triage process with a serverless architecture, I reduced response times from hours to seconds and eliminated context switching, demonstrating how lightweight automation can drive tangible business value.

## The Challenge

As a solo studio operator, managing inquiries became a bottleneck that penalized creative work.
*   **Context Switching:** Every inquiry interrupted deep work, requiring me to cross-reference calendars, pricing PDFs, and policy documents.
*   **Latency:** Average response time lagged significantly (often hours), allowing high-intent leads to go cold.
*   **Scalability:** Existing no-code solutions (n8n) were too slow (minutes to execution) and expensive to scale (~$70/mo).

## The Solution

I engineered a **Serverless TypeScript architecture** that treats email inquiries as events. The system parses intent using LLMs, checks real-time availability, and drafts context-aware responses without human intervention.

<div className="not-prose my-8 overflow-hidden rounded-xl border border-zinc-200 bg-zinc-50 dark:border-zinc-800 dark:bg-zinc-900">
    <video 
        className="w-full aspect-video" 
        controls 
        autoPlay 
        muted 
        loop
        playsInline
    >
        <source src="/email-automation/Email-Agent-Render.mp4" type="video/mp4" />
        Your browser does not support the video tag.
    </video>
</div>

### System Architecture

The pipeline is entirely event-driven with zero idle costs, ensuring sub-second triggers.

<div className="not-prose my-12 -mx-6 md:mx-0 overflow-x-auto">
    <FlowDiagram />
</div>

1.  **Ingestion (Pub/Sub):** Gmail webhook fires immediately upon email receipt.
2.  **State Management (Gmail Labels):** The system "locks" the thread using a specific label (`processed by TRISP AI`) to prevent race conditions and ensure idempotency.
3.  **Intent Extraction (Gemini AI):** Raw email text is converted into structured JSON (`{ name, email, session_type, preferred_date, preferred_time, location, notes }`) using Gemini 3 Pro with strict schema enforcement.
4.  **Business Logic:**
    *   **Availability:** Queries Google Calendar API. If busy, an algorithm calculates 3 nearest alternative slots.
    *   **Guardrails:** TypeScript configuration files (`pricing.ts`, `policies.ts`) serve as the source of truth, preventing AI from inventing prices or policy details.
5.  **Response Generation:** Gemini drafts the email using the structured data and brand voice guidelines.
6.  **Action:** The draft is inserted into the thread for final one-click approval.




## Key Technical Decisions

### Sentinel Labels for State
Instead of maintaining a dedicated database (Postgres/Redis) for a simple workflow, I used Gmail Labels as a **finite state machine**. The system applies a 'processed by TRISP AI' label immediately upon claiming a thread, preventing race conditions in parallel webhook executions. This kept the architecture stateless and strictly free-tier.

### Immediate State Claiming
The system marks threads as 'processed' before slow AI operations (not after), preventing duplicate processing when multiple webhooks fire simultaneously. This pattern ensures idempotency without database overhead.

### Deterministic Guardrails
To solve the risk of "AI hallucinations" (e.g., inventing low prices), I separated concerns:
*   **AI** handles language and tone.
*   **Code** handles facts (Price, Availability, Policy).
The AI is provided strict context and cannot "guess" numbers.

### Interactive Demo

See the system in action. Click through the tabs to explore the flow:

<BookingAgentDemo />

## Impact & Results

<div className="not-prose my-8 flex justify-center gap-8 text-center">
    <div className="rounded-xl bg-emerald-50 dark:bg-emerald-950/30 border border-emerald-200 dark:border-emerald-800 px-6 py-4">
        <div className="text-3xl font-bold text-emerald-600 dark:text-emerald-400">99%</div>
        <div className="text-sm text-emerald-700 dark:text-emerald-300">Faster</div>
    </div>
    <div className="rounded-xl bg-emerald-50 dark:bg-emerald-950/30 border border-emerald-200 dark:border-emerald-800 px-6 py-4">
        <div className="text-3xl font-bold text-emerald-600 dark:text-emerald-400">62%</div>
        <div className="text-sm text-emerald-700 dark:text-emerald-300">Cheaper</div>
    </div>
    <div className="rounded-xl bg-emerald-50 dark:bg-emerald-950/30 border border-emerald-200 dark:border-emerald-800 px-6 py-4">
        <div className="text-3xl font-bold text-emerald-600 dark:text-emerald-400">&lt;1%</div>
        <div className="text-sm text-emerald-700 dark:text-emerald-300">Error Rate</div>
    </div>
</div>

<div className="not-prose my-8 space-y-8">
  <WorkflowComparisonTable />
  <ResultsTable />
</div>

*   **99% faster** response time vs manual process (15-20 min → < 30 sec)
*   **62% cost reduction** vs No-Code platforms (~$70/mo → ~$27/mo)
*   **Zero context switching** — runs completely in background
*   **< 1% error rate** — deterministic guardrails prevent mistakes
