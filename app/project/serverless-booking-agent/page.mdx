
import Image from 'next/image'
import { ResultsTable } from '@/components/results-table'
import { FlowDiagram } from '@/components/flow-diagram'
import { ZoomableImage } from '@/components/ui/zoomable-image'

export const metadata = {
  title: 'Serverless Booking Agent',
  description: 'A technical case study on replacing a manual 10-hour/week workflow with a Serverless TypeScript architecture.',
}

<div className="not-prose mb-8 overflow-hidden rounded-2xl bg-zinc-50/40 p-1 ring-1 ring-zinc-200/50 ring-inset dark:bg-zinc-950/40 dark:ring-zinc-800/50">
  <ZoomableImage
    src="/automating email.png"
    alt="The Serverless Booking Agent: 4 Hours to 20 Seconds"
    width={1200}
    height={675}
    className="w-full rounded-xl object-cover"
    priority
  />
</div>

# Serverless Booking Agent

**Role:** Technical Product Manager & Developer | **Timeline:** Oct 2025 - Present  
**Tech Stack:** TypeScript, Vercel Serverless Functions, Google Gemini AI, Google Pub/Sub, Gmail API

---

## Overview

A fully automated, event-driven system that handles photography inquiries instantly. By replacing a manual triage process with a serverless architecture, I reduced response times from 4 hours to 20 seconds and eliminated context switching, demonstrating how lightweight automation can drive tangible business value.

## The Challenge

As a solo studio operator, managing inquiries became a bottleneck that penalized creative work.
*   **Context Switching:** Every inquiry interrupted deep work, requiring me to cross-reference calendars, pricing PDFs, and policy documents.
*   **Latency:** Average response time lagged to ~4 hours, allowing high-intent leads to go cold.
*   **Scalability:** Existing no-code solutions (n8n) were too slow (minutes to execution) and expensive to scale (~$70/mo).

## The Solution

I engineered a **Serverless TypeScript architecture** that treats email inquiries as events. The system parses intent using LLMs, checks real-time availability, and drafts context-aware responses without human intervention.

### System Architecture

The pipeline is entirely event-driven, ensuring zero idle costs and sub-second triggers.

<div className="not-prose my-12 -mx-6 md:mx-0 overflow-x-auto">
    <FlowDiagram />
</div>

1.  **Ingestion (Pub/Sub):** Gmail webhook fires immediately upon email receipt.
2.  **State Management (Gmail Labels):** The system "locks" the thread using a specific label (`processed-by-ai`) to prevent race conditions and ensure idempotency.
3.  **Intent Extraction (Gemini AI):** Raw text is converted into structured JSON (`{ intent, date, session_type }`).
4.  **Business Logic:**
    *   **Availability:** Queries Google Calendar API. If busy, an algorithm calculates 3 nearest alternative slots.
    *   **Guardrails:** Hardcoded TypeScript configuration files serve as the "source of truth" for pricing and policies, preventing AI hallucination.
5.  **Response Generation:** Gemini drafts the email using the structured data and brand voice guidelines.
6.  **Action:** The draft is inserted into the thread for final one-click approval (or auto-send).

## Key Technical Decisions

### Sentinel Labels for State
Instead of maintaining a dedicated database (Postgres/Redis) for a simple workflow, I used Gmail Labels as a **finite state machine**. This kept the architecture stateless and strictly free-tier.

### Deterministic Guardrails
To solve the risk of "AI hallucinations" (e.g., inventing low prices), I separated concerns:
*   **AI** handles language and tone.
*   **Code** handles facts (Price, Availability, Policy).
The AI is provided strict context and cannot "guess" numbers.

## Impact & Results

<div className="not-prose my-8">
  <ResultsTable />
</div>

*   **99% Reduction** in response latency (4 hours â†’ ~20 seconds).
*   **Zero infrastructure cost** (running entirely on Vercel free tier).
*   **Waitlist Growth:** Faster responses led to higher conversion and a booked-out calendar.
